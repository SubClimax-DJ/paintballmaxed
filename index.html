<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Ball Paintball Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Base body styles */
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            position: relative;
        }
        /* Canvas styles */
        canvas {
            display: block;
            background-color: #2d3748;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 25px 25px;
            border: 4px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 85vh;
            aspect-ratio: 16 / 9;
            cursor: crosshair;
        }
        /* Container for game elements */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            width: 95%;
            max-width: 1200px;
            visibility: hidden; /* Hide game container initially */
        }
        .game-container.active {
             visibility: visible; /* Show when game starts */
        }

        /* --- UI Polish Starts --- */

        /* Top panel styles */
        .top-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0.5rem 1rem; /* Adjusted padding */
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            gap: 1rem;
            background-color: rgba(45, 55, 72, 0.5); /* Subtle background */
            border: 2px solid #4a5568;
            border-radius: 6px;
        }
        /* Team score container */
        .team-scores {
            display: flex;
            justify-content: center;
            gap: 2rem;
            font-size: 1.1rem; /* Slightly larger scores */
            font-weight: bold; /* Bolder scores */
            order: 1;
            font-family: 'Press Start 2P', cursive; /* Ensure font */
        }
        /* Game stats container (timer, overall score) */
        .game-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
            order: 2;
            font-family: 'Press Start 2P', cursive; /* Ensure font */
        }
        /* Timer display style */
        .timer {
            font-size: 1.2rem;
            color: #fbd38d;
        }
        /* Overall score display style */
        .overall-score {
            font-size: 0.7rem; /* Keep smaller for hierarchy */
            color: #a0aec0;
            margin-top: 0.25rem;
            text-align: center; /* Center align */
        }
        /* Score colors set dynamically */
        .score-team1 {}
        .score-team2 {}

        /* Bottom panel styles */
        .bottom-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0.5rem 1rem; /* Adjusted padding */
            margin-top: 0.5rem;
            flex-wrap: wrap;
            gap: 0.5rem;
            background-color: rgba(45, 55, 72, 0.5); /* Subtle background */
            border: 2px solid #4a5568;
            border-radius: 6px;
        }
        /* Info panel (controls, game state) */
        .info-panel {
            font-size: 0.75rem;
            color: #a0aec0;
            text-align: left;
            flex-grow: 1;
            font-family: 'Press Start 2P', cursive; /* Ensure font */
            line-height: 1.4; /* Improve readability */
        }
         .info-panel div { /* Style individual lines */
             margin-bottom: 0.2rem;
         }
        /* Controls container (reset button) */
        .controls-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            order: 3;
        }
        /* Shared button base style */
        .game-button {
             font-family: 'Press Start 2P', cursive;
             border: 2px solid;
             padding: 8px 16px;
             font-size: 0.8rem;
             border-radius: 6px;
             cursor: pointer;
             transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.1s ease; /* Added box-shadow transition */
             box-shadow: 0 3px 5px rgba(0,0,0,0.4); /* Slightly stronger shadow */
             white-space: nowrap;
             text-transform: uppercase; /* Uppercase button text */
        }
        .game-button:active {
            transform: translateY(2px); /* Slightly more press depth */
            box-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        /* Reset Button Specific Style */
        .reset-button {
            background-color: #fbd38d; color: #2d3748; border-color: #f6ad55;
        }
        .reset-button:hover { background-color: #f6ad55; }

        /* Menu Button Specific Style */
        .menu-button {
            background-color: #f56565; color: #1a202c; border-color: #c53030;
        }
        .menu-button:hover { background-color: #e53e3e; }

        /* --- UI Polish Ends --- */

        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); color: white; padding: 25px 45px; border-radius: 10px; font-size: 1.8rem; text-align: center; z-index: 100; display: none; border: 3px solid #cbd5e0; box-shadow: 0 5px 15px rgba(0,0,0,0.4); }
        .bunker { fill: #8c7a51; stroke: #5a4d35; stroke-width: 1.5; }
        .eliminated { opacity: 0.4; }

        /* --- Start Menu Styles --- */
        #startMenu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(26, 32, 44, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; color: #e2e8f0; font-family: 'Press Start 2P', cursive;
            padding: 1rem; box-sizing: border-box; text-align: center;
            overflow-y: auto;
        }
        #startMenu img {
            max-width: 80%; max-height: 200px; height: auto; margin-bottom: 1.5rem;
            border-radius: 8px; border: 3px solid #4a5568; box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        #startMenu h1 { font-size: 2rem; margin-bottom: 1.5rem; color: #fbd38d; text-shadow: 2px 2px #c05621; }
        .menu-options {
            background-color: #2d3748; padding: 1.5rem 2rem; border-radius: 8px;
            border: 3px solid #4a5568; box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; gap: 1rem; align-items: center;
            width: 90%; max-width: 550px; margin-bottom: 3rem; /* Add margin for credit */
        }
        .option-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem 1.5rem; width: 100%; }
        .option-group { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; width: auto; }
        .option-group label { font-size: 0.8rem; color: #a0aec0; white-space: nowrap; }
        .option-group input[type="number"], .option-group select { font-family: 'Press Start 2P', cursive; font-size: 0.9rem; padding: 8px 10px; background-color: #1a202c; border: 2px solid #4a5568; color: #e2e8f0; border-radius: 4px; text-align: center; }
        .option-group input[type="number"] { width: 70px; -moz-appearance: textfield; }
        .option-group input[type="number"]::-webkit-outer-spin-button, .option-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .option-group select { width: 200px; text-align-last: center; cursor: pointer; }
        .option-group select option { background-color: #2d3748; color: #e2e8f0; font-size: 0.8rem; }
        #startButton { font-family: 'Press Start 2P', cursive; background-color: #68d391; color: #1a202c; border: 2px solid #38a169; padding: 10px 20px; font-size: 1rem; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; box-shadow: 0 3px 6px rgba(0,0,0,0.3); margin-top: 1rem; text-transform: uppercase; }
        #startButton:hover { background-color: #48bb78; }
        #startButton:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        /* Creator Credit Style */
        .creator-credit {
            position: absolute;
            bottom: 10px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            font-size: 0.65rem; /* Small font size */
            color: #718096; /* Gray color */
            opacity: 0.8; /* Slightly faded */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen">

    <div id="startMenu">
         <img src="https://i.postimg.cc/jq4cVDfK/LAttributes.png"
             alt="Paintball Game Banner"
             onerror="this.onerror=null; this.src='https://placehold.co/600x200/2d3748/e2e8f0?text=Image+Error';">

        <div class="menu-options">
            <h1>X-Ball</h1>
            <div class="option-row">
                <div class="option-group">
                    <label for="playerCountInput">Players/Team:</label>
                    <input type="number" id="playerCountInput" value="5" min="1" max="10">
                </div>
                <div class="option-group">
                    <label for="timeLimitInput">Time (sec):</label>
                    <input type="number" id="timeLimitInput" value="60" min="10" max="300">
                </div>
                 <div class="option-group">
                    <label for="roundsInput">Rounds:</label>
                    <input type="number" id="roundsInput" value="3" min="1" max="15"> </div>
            </div>
             <div class="option-group">
                <label for="mapLayoutInput">Map Layout:</label>
                <select id="mapLayoutInput">
                    <option value="nxl_2023" selected>NXL 2023</option>
                    <option value="nxl_2020">NXL 2020</option> </select>
            </div>
             <div class="option-row">
                 <div class="option-group">
                    <label for="userTeamSelect">Your Team:</label>
                    <select id="userTeamSelect"></select> </div>
                <div class="option-group">
                    <label for="opponentTeamSelect">Opponent:</label>
                    <select id="opponentTeamSelect"></select> </div>
            </div>
            <button id="startButton">Start Match</button>
        </div>
         <p class="creator-credit">Created by Max Prebeg</p>
    </div>

    <div class="game-container">
        <div class="top-panel">
            <div class="team-scores">
                 <div id="scoreTeam1" class="score-team1">Team1: 0</div>
                <div id="scoreTeam2" class="score-team2">Team2: 0</div>
            </div>
            <div class="game-stats">
                 <div id="timerDisplay" class="timer">Time: 0</div>
                 <div id="overallScoreDisplay" class="overall-score">Round: 1 / 3 | Wins: Team1 0 - Team2 0</div>
            </div>
            <div style="order: 3; flex-basis: 100px; visibility: hidden;"></div>
       </div>
        <canvas id="gameCanvas"></canvas>
        <div class="bottom-panel">
             <div class="info-panel">
                 <div>Controls: WASD/Arrows to Move</div>
                 <div>Click/Tap to Shoot</div>
                 <div id="gameState">Game State: Ready</div>
             </div>
             <div class="controls-container">
                 <button id="resetButton" class="game-button reset-button">Reset Round</button>
                 <button id="menuButton" class="game-button menu-button">Main Menu</button> </div>
        </div>
        <div id="messageBox" class="message-box"></div>
    </div>

    <audio id="audioShoot" src="sounds/shoot.wav" preload="auto"></audio>
    <audio id="audioHitPlayer" src="sounds/hit_player.wav" preload="auto"></audio>
    <audio id="audioHitBunker" src="sounds/hit_bunker.wav" preload="auto"></audio>
    <audio id="audioWin" src="sounds/win.wav" preload="auto"></audio>
    <audio id="audioLose" src="sounds/lose.wav" preload="auto"></audio>
    <audio id="audioStart" src="sounds/start.wav" preload="auto"></audio>
    <script>
        // --- Canvas and DOM Element Setup ---
        const canvas = document.getElementById('gameCanvas'); /* ... */ const ctx = canvas.getContext('2d'); /* ... */
        const scoreTeam1Element = document.getElementById('scoreTeam1'); /* ... */ const scoreTeam2Element = document.getElementById('scoreTeam2'); /* ... */
        const gameStateElement = document.getElementById('gameState'); /* ... */ const timerDisplayElement = document.getElementById('timerDisplay'); /* ... */
        const overallScoreDisplayElement = document.getElementById('overallScoreDisplay'); /* ... */
        const resetButton = document.getElementById('resetButton'); /* ... */ const menuButton = document.getElementById('menuButton'); /* ... */
        const messageBox = document.getElementById('messageBox'); /* ... */ const gameContainer = document.querySelector('.game-container'); /* ... */

        // --- Menu Elements ---
        const startMenu = document.getElementById('startMenu'); /* ... */ const playerCountInput = document.getElementById('playerCountInput'); /* ... */
        const timeLimitInput = document.getElementById('timeLimitInput'); /* ... */ const mapLayoutInput = document.getElementById('mapLayoutInput'); /* ... */
        const userTeamSelect = document.getElementById('userTeamSelect'); /* ... */ const opponentTeamSelect = document.getElementById('opponentTeamSelect'); /* ... */
        const roundsInput = document.getElementById('roundsInput'); /* ... */
        const startButton = document.getElementById('startButton'); /* ... */

        // --- Audio Element References ---
        const audioShoot = document.getElementById('audioShoot'); /* ... */ const audioHitPlayer = document.getElementById('audioHitPlayer'); /* ... */
        const audioHitBunker = document.getElementById('audioHitBunker'); /* ... */ const audioWin = document.getElementById('audioWin'); /* ... */
        const audioLose = document.getElementById('audioLose'); /* ... */ const audioStart = document.getElementById('audioStart'); /* ... */

        // --- Team Data ---
        const teams = [ /* ... same team data ... */ { id: 'dynasty', name: 'Dynasty', color: 'hsl(230, 70%, 60%)' }, { id: 'heat', name: 'Heat', color: 'hsl(0, 80%, 55%)' }, { id: 'aftershock', name: 'Aftershock', color: 'hsl(210, 5%, 40%)' }, { id: 'acdallas', name: 'ac DALLAS', color: 'hsl(210, 10%, 75%)' }, { id: 'damage', name: 'Damage', color: 'hsl(0, 45%, 40%)' }, { id: 'impact', name: 'Impact', color: 'hsl(120, 60%, 30%)' }, { id: 'upton', name: 'Upton 187', color: 'hsl(275, 80%, 60%)' }, { id: 'xfactor', name: 'X-Factor', color: 'hsl(60, 100%, 55%)' } ];

        // --- Global Game State ---
        let team1Score = 0; /* ... */ let team2Score = 0; /* ... */
        let team1GamesWon = 0; /* ... */ let team2GamesWon = 0; /* ... */
        let gameActive = false; /* ... */ let animationFrameId = null; /* ... */
        let timerIntervalId = null; /* ... */ let timeRemaining; /* ... */
        let currentRoundNumber = 1; /* ... */

        // --- Selected Game Options (set by menu) ---
        let selectedPlayerCount = 5; /* ... */ let selectedRoundTime = 60; /* ... */
        let selectedMapLayout = 'nxl_2023'; /* ... */ let selectedUserTeam = teams[0]; /* ... */
        let selectedOpponentTeam = teams[1]; /* ... */
        let selectedRoundsPerMatch = 3; /* ... */

        // --- Game Constants ---
        const PLAYER_RADIUS = 10; /* ... */ const PLAYER_SPEED = 4.0; /* ... */
        const PAINTBALL_RADIUS = 4; /* ... */ const PAINTBALL_SPEED = 8; /* ... */
        const AI_SHOOT_INTERVAL = 250; /* ... */ const AI_MOVE_INTERVAL = 1000; /* ... */
        const AI_MOVE_TARGET_RANGE = 120; /* ... */ const AI_VIEW_RANGE = 300; /* ... */
        const BUNKER_SIZE_MULTIPLIER = 0.8; /* ... */ const COLLISION_NUDGE_FACTOR = 0.6; /* ... */
        const TEAMMATE_REPULSION_DISTANCE = PLAYER_RADIUS * 4.0; /* ... */ const TEAMMATE_REPULSION_FORCE = 0.4; /* ... */
        const FACING_INDICATOR_LENGTH = PLAYER_RADIUS * 1.5; /* ... */
        const NEXT_ROUND_DELAY = 3000; /* ... */

        // --- Splat Constants ---
        const SPLAT_RADIUS_BASE = 8; /* ... */ const SPLAT_RADIUS_VARIANCE = 4; /* ... */
        const SPLAT_DURATION = 1500; /* ... */

        // --- Game Objects ---
        let userPlayer; /* ... */ const team1Players = []; /* ... */ const team2Players = []; /* ... */
        const paintballs = []; /* ... */ const bunkers = []; /* ... */
        let bunkerLookup = {}; /* ... */ const splats = []; /* ... */

        // --- Input Handling (Keyboard) ---
        const keys = { w: false, a: false, s: false, d: false };
        document.addEventListener('keydown', (e) => { /* ... same ... */ const key = e.key.toLowerCase(); if (key === 'w' || key === 'arrowup') keys.w = true; if (key === 'a' || key === 'arrowleft') keys.a = true; if (key === 's' || key === 'arrowdown') keys.s = true; if (key === 'd' || key === 'arrowright') keys.d = true; });
        document.addEventListener('keyup', (e) => { /* ... same ... */ const key = e.key.toLowerCase(); if (key === 'w' || key === 'arrowup') keys.w = false; if (key === 'a' || key === 'arrowleft') keys.a = false; if (key === 's' || key === 'arrowdown') keys.s = false; if (key === 'd' || key === 'arrowright') keys.d = false; });

        // --- Utility Functions ---
        function distToSegmentSquared(x1, y1, x2, y2, px, py) { /* ... same ... */ const l2 = (x2 - x1)**2 + (y2 - y1)**2; if (l2 === 0) return (px - x1)**2 + (py - y1)**2; let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2; t = Math.max(0, Math.min(1, t)); const projX = x1 + t * (x2 - x1); const projY = y1 + t * (y2 - y1); return (px - projX)**2 + (py - projY)**2; }
        function lineIntersectsRect(x1, y1, x2, y2, rect) { /* ... same ... */ return ( lineIntersectsLine(x1, y1, x2, y2, rect.x, rect.y, rect.x + rect.width, rect.y) || lineIntersectsLine(x1, y1, x2, y2, rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height) || lineIntersectsLine(x1, y1, x2, y2, rect.x + rect.width, rect.y + rect.height, rect.x, rect.y + rect.height) || lineIntersectsLine(x1, y1, x2, y2, rect.x, rect.y + rect.height, rect.x, rect.y) ); }
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) { /* ... same ... */ const den = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1); if (Math.abs(den) < 1e-6) return false; const ua_num = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)); const ub_num = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)); const ua = ua_num / den; const ub = ub_num / den; const tolerance = 1e-6; return ua >= -tolerance && ua <= 1 + tolerance && ub >= -tolerance && ub <= 1 + tolerance; }
        function findNearestBunker(x, y) { /* ... same ... */ let nearestBunker = null; let minDistanceSq = Infinity; for (const bunker of bunkers) { const bunkerCenterX = bunker.x + bunker.width / 2; const bunkerCenterY = bunker.y + bunker.height / 2; const distanceSq = (x - bunkerCenterX)**2 + (y - bunkerCenterY)**2; if (distanceSq < minDistanceSq) { minDistanceSq = distanceSq; nearestBunker = bunker; } } return nearestBunker; }
        function getTeamById(id) { return teams.find(team => team.id === id); }

        // --- Collision Detection ---
        function isCollidingWithBunker(x, y, radius) { /* ... same ... */ for (const bunker of bunkers) { const closestX = Math.max(bunker.x, Math.min(x, bunker.x + bunker.width)); const closestY = Math.max(bunker.y, Math.min(y, bunker.y + bunker.height)); const dist = Math.hypot(x - closestX, y - closestY); if (dist < radius) return true; } return false; }
        function getCollidingBunker(x, y, radius) { /* ... same ... */ for (const bunker of bunkers) { const closestX = Math.max(bunker.x, Math.min(x, bunker.x + bunker.width)); const closestY = Math.max(bunker.y, Math.min(y, bunker.y + bunker.height)); const dist = Math.hypot(x - closestX, y - closestY); if (dist < radius) return bunker; } return null; }

        // --- Line of Sight ---
        function hasLineOfSight(x1, y1, x2, y2) { /* ... same ... */ for (const bunker of bunkers) { const rect = { x: bunker.x, y: bunker.y, width: bunker.width, height: bunker.height }; const bunkerCenterX = rect.x + rect.width / 2; const bunkerCenterY = rect.y + rect.height / 2; if (distToSegmentSquared(x1, y1, x2, y2, bunkerCenterX, bunkerCenterY) < Math.max(rect.width, rect.height)**2 * 1.5) { if (lineIntersectsRect(x1, y1, x2, y2, rect)) return false; } } return true; }

        // --- Bunker Setup Functions ---
        const addBunker = (name, props) => { /* ... same ... */ const bunker = { name, shape: 'rect', ...props }; bunkers.push(bunker); if (name) bunkerLookup[name] = bunker; };
        const addSymmetrical = (baseName, props) => { /* ... same ... */ const w = canvas.width; const BSM = BUNKER_SIZE_MULTIPLIER; const adjustedX = props.x + (props.width / BSM - props.width) / 2; const adjustedY = props.y + (props.height / BSM - props.height) / 2; const mirroredX = w - adjustedX - props.width; addBunker(`${baseName}_L`, { ...props, x: adjustedX, y: adjustedY }); addBunker(`${baseName}_R`, { ...props, x: mirroredX, y: adjustedY }); };
        function setupBunkersNXL2023() { /* ... same ... */ bunkers.length = 0; bunkerLookup = {}; const w = canvas.width; const h = canvas.height; const BSM = BUNKER_SIZE_MULTIPLIER; console.log(`Setting up bunkers: NXL 2023 on ${w}x${h}`); const smallCanW = w * 0.03 * BSM; const smallCanH = h * 0.06 * BSM; const tallCanW = w * 0.035 * BSM; const tallCanH = h * 0.12 * BSM; const brickW = w * 0.06 * BSM; const brickH = h * 0.06 * BSM; const templeW = w * 0.05 * BSM; const templeH = h * 0.15 * BSM; const doritoW = w * 0.05 * BSM; const doritoH = h * 0.15 * BSM; const snakeBeamW = w * 0.12 * BSM; const snakeBeamH = h * 0.05 * BSM; const centerBaseW = w * 0.08 * BSM; const centerBaseH = h * 0.18 * BSM; addSymmetrical('backCorner', { x: w * 0.05, y: h * 0.1, width: brickW * 1.2, height: brickH * 1.2 }); addSymmetrical('backCornerSnake', { x: w * 0.05, y: h * 0.9 - brickH * 1.2, width: brickW * 1.2, height: brickH * 1.2 }); addBunker('backCenter_T', { x: w * 0.5 - tallCanW / 2, y: h * 0.05, width: tallCanW, height: tallCanH }); addBunker('backCenter_B', { x: w * 0.5 - tallCanW / 2, y: h * 0.95 - tallCanH, width: tallCanW, height: tallCanH }); addSymmetrical('snakeSide', { x: w * 0.08, y: h * 0.75, width: brickW, height: brickH }); addSymmetrical('snake1', { x: w * 0.2, y: h * 0.95 - snakeBeamH, width: snakeBeamW, height: snakeBeamH }); addSymmetrical('snake2', { x: w * 0.35, y: h * 0.95 - snakeBeamH, width: snakeBeamW * 0.8, height: snakeBeamH }); addSymmetrical('snakeMini', { x: w * 0.15, y: h * 0.8, width: smallCanW, height: smallCanH }); addSymmetrical('snakeBackCan', { x: w*0.18, y: h * 0.9 - smallCanH, width: smallCanW, height: smallCanH}); addSymmetrical('dorito1', { x: w * 0.15, y: h * 0.15, width: doritoW, height: doritoH }); addSymmetrical('dorito2', { x: w * 0.28, y: h * 0.08, width: doritoW, height: doritoH }); addSymmetrical('doritoSideCan', { x: w * 0.18, y: h * 0.3, width: smallCanW, height: smallCanH }); addSymmetrical('doritoFwdCan', { x: w * 0.35, y: h * 0.2, width: smallCanW, height: smallCanH }); addBunker('centerBase', { x: w * 0.5 - centerBaseW / 2, y: h * 0.5 - centerBaseH / 2, width: centerBaseW, height: centerBaseH }); addSymmetrical('temple', { x: w * 0.38, y: h * 0.5 - templeH / 2, width: templeW, height: templeH }); addSymmetrical('midCakeD', { x: w * 0.3, y: h * 0.35, width: brickW, height: brickH }); addSymmetrical('midCakeS', { x: w * 0.3, y: h * 0.65 - brickH, width: brickW, height: brickH }); addSymmetrical('midCanD', { x: w * 0.42, y: h * 0.25, width: smallCanW, height: smallCanH }); addSymmetrical('midCanS', { x: w * 0.42, y: h * 0.75 - smallCanH, width: smallCanW, height: smallCanH }); }
        function setupBunkersNXL2020() { /* ... same ... */ bunkers.length = 0; bunkerLookup = {}; const w = canvas.width; const h = canvas.height; const BSM = BUNKER_SIZE_MULTIPLIER; console.log(`Setting up bunkers: NXL 2020 on ${w}x${h}`); const smallCanW = w * 0.03 * BSM; const smallCanH = h * 0.06 * BSM; const tallCakeW = w * 0.06 * BSM; const tallCakeH = h * 0.12 * BSM; const brickW = w * 0.06 * BSM; const brickH = h * 0.06 * BSM; const doritoW = w * 0.05 * BSM; const doritoH = h * 0.15 * BSM; const snakeBeamW = w * 0.12 * BSM; const snakeBeamH = h * 0.05 * BSM; const centerBaseW = w * 0.05 * BSM; const centerBaseH = h * 0.18 * BSM; const pinW = w * 0.02 * BSM; const pinH = h * 0.04 * BSM; addSymmetrical('backCornerTCK', { x: w * 0.05, y: h * 0.1, width: tallCakeW, height: tallCakeH }); addBunker('backCenterTCK_T', { x: w * 0.5 - tallCakeW / 2, y: h * 0.05, width: tallCakeW, height: tallCakeH }); addBunker('backCenterTCK_B', { x: w * 0.5 - tallCakeW / 2, y: h * 0.95 - tallCakeH, width: tallCakeW, height: tallCakeH }); addSymmetrical('snake1', { x: w * 0.15, y: h * 0.95 - snakeBeamH, width: snakeBeamW * 0.8, height: snakeBeamH }); addSymmetrical('snake2', { x: w * 0.3, y: h * 0.95 - snakeBeamH, width: snakeBeamW * 0.8, height: snakeBeamH }); addSymmetrical('snake3', { x: w * 0.4, y: h * 0.95 - snakeBeamH, width: snakeBeamW * 0.5, height: snakeBeamH }); addSymmetrical('snakeMiniCake', { x: w * 0.08, y: h * 0.75, width: brickW*0.8, height: brickH*0.8 }); addSymmetrical('dorito1', { x: w * 0.1, y: h * 0.2, width: doritoW, height: doritoH }); addSymmetrical('dorito2', { x: w * 0.25, y: h * 0.1, width: doritoW, height: doritoH }); addSymmetrical('dorito3', { x: w * 0.38, y: h * 0.05, width: doritoW, height: doritoH }); addSymmetrical('doritoMiniCake', { x: w * 0.08, y: h * 0.25, width: brickW*0.8, height: brickH*0.8 }); addBunker('centerBaseTop', { x: w * 0.5 - centerBaseW / 2, y: h * 0.3 - centerBaseH / 2, width: centerBaseW, height: centerBaseH }); addBunker('centerBaseBottom', { x: w * 0.5 - centerBaseW / 2, y: h * 0.7 - centerBaseH / 2, width: centerBaseW, height: centerBaseH }); addSymmetrical('centerPin1', { x: w * 0.4, y: h * 0.35, width: pinW, height: pinH }); addSymmetrical('centerPin2', { x: w * 0.4, y: h * 0.65 - pinH, width: pinW, height: pinH }); addSymmetrical('midBrick1', { x: w * 0.2, y: h * 0.65, width: brickW, height: brickH }); addSymmetrical('midBrick2', { x: w * 0.35, y: h * 0.5 - brickH/2, width: brickW, height: brickH }); }

        // --- Player Creation ---
        function createPlayer(teamData, isUser = false) { /* ... same ... */ const player = { x: 0, y: 0, radius: PLAYER_RADIUS, color: teamData.color, team: teamData, speed: PLAYER_SPEED, dx: 0, dy: 0, isUser: isUser, isEliminated: false, outlineColor: isUser ? '#fff' : null, facingAngle: teamData === selectedUserTeam ? 0 : Math.PI, ai: { state: 'spawning', lastMoveTime: 0, lastShootTime: 0, targetX: 0, targetY: 0, targetBunker: null, moving: false } }; return player; }

        // --- Shooting ---
        function shootPaintball(shooter, targetX, targetY) { /* ... same ... */ if (shooter.isEliminated || !gameActive) return; const angle = Math.atan2(targetY - shooter.y, targetX - shooter.x); shooter.facingAngle = angle; paintballs.push({ x: shooter.x, y: shooter.y, radius: PAINTBALL_RADIUS, color: shooter.color, dx: Math.cos(angle) * PAINTBALL_SPEED, dy: Math.sin(angle) * PAINTBALL_SPEED, team: shooter.team }); if (audioShoot) { audioShoot.currentTime = 0; audioShoot.play().catch(e => console.error("Error playing shoot sound:", e)); } }
        function handleUserShoot(event) { /* ... same ... */ if (!gameActive || !userPlayer || userPlayer.isEliminated) return; event.preventDefault(); let clickX, clickY; const rect = canvas.getBoundingClientRect(); if (event.touches && event.touches.length > 0) { clickX = event.touches[0].clientX - rect.left; clickY = event.touches[0].clientY - rect.top; } else { clickX = event.clientX - rect.left; clickY = event.clientY - rect.top; } clickX *= canvas.width / rect.width; clickY *= canvas.height / rect.height; shootPaintball(userPlayer, clickX, clickY); }
        canvas.addEventListener('click', handleUserShoot);
        canvas.addEventListener('touchstart', handleUserShoot);

        // --- Splat Creation ---
        function createSplat(x, y, color) { /* ... same ... */ const splat = { x: x, y: y, color: color, radius: SPLAT_RADIUS_BASE + (Math.random() * SPLAT_RADIUS_VARIANCE * 2) - SPLAT_RADIUS_VARIANCE, creationTime: Date.now(), duration: SPLAT_DURATION + (Math.random() * 500) - 250 }; splats.push(splat); }

        // --- Drawing Functions ---
        function drawBunkers() { /* ... same ... */ ctx.fillStyle = '#8c7a51'; ctx.strokeStyle = '#5a4d35'; ctx.lineWidth = 1.5; bunkers.forEach(bunker => { ctx.beginPath(); ctx.rect(bunker.x, bunker.y, bunker.width, bunker.height); ctx.fill(); ctx.stroke(); }); }
        function drawPlayer(player) { /* ... same ... */ ctx.globalAlpha = player.isEliminated ? 0.4 : 1.0; ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fillStyle = player.color; ctx.fill(); if (player.outlineColor && !player.isEliminated) { ctx.strokeStyle = player.outlineColor; ctx.lineWidth = 2; ctx.stroke(); } if (!player.isEliminated) { ctx.beginPath(); ctx.moveTo(player.x, player.y); const indicatorEndX = player.x + Math.cos(player.facingAngle) * FACING_INDICATOR_LENGTH; const indicatorEndY = player.y + Math.sin(player.facingAngle) * FACING_INDICATOR_LENGTH; ctx.lineTo(indicatorEndX, indicatorEndY); ctx.strokeStyle = '#1a202c'; ctx.lineWidth = 3; ctx.stroke(); } ctx.closePath(); ctx.globalAlpha = 1.0; }
        function drawPaintballs() { /* ... same ... */ paintballs.forEach(paintball => { ctx.beginPath(); ctx.arc(paintball.x, paintball.y, paintball.radius, 0, Math.PI * 2); ctx.fillStyle = paintball.color; ctx.fill(); ctx.closePath(); }); }
        function drawSplats() { /* ... same ... */ const now = Date.now(); splats.forEach(splat => { const age = now - splat.creationTime; const alpha = 1.0 - Math.min(1.0, age / splat.duration); if (alpha <= 0) return; ctx.save(); ctx.globalAlpha = alpha * 0.8; ctx.fillStyle = splat.color; ctx.beginPath(); ctx.moveTo(splat.x + splat.radius, splat.y); for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) { const randomOffset = splat.radius * (0.8 + Math.random() * 0.4); ctx.lineTo( splat.x + Math.cos(angle) * randomOffset, splat.y + Math.sin(angle) * randomOffset ); } ctx.closePath(); ctx.fill(); ctx.restore(); }); ctx.globalAlpha = 1.0; }


        // --- Update Functions ---
        function updatePlayer(player) { /* ... same ... */ if (player.isEliminated || !gameActive) return; let targetDx = 0; let targetDy = 0; const now = Date.now(); let repulsionDx = 0; let repulsionDy = 0; if (player.isUser) { if (keys.w) targetDy = -player.speed; if (keys.s) targetDy = player.speed; if (keys.a) targetDx = -player.speed; if (keys.d) targetDx = player.speed; } else { const state = player.ai.state; const teammates = (player.team === selectedUserTeam) ? team1Players : team2Players; teammates.forEach(teammate => { if (player === teammate || teammate.isEliminated) return; const distSq = (player.x - teammate.x)**2 + (player.y - teammate.y)**2; if (distSq < TEAMMATE_REPULSION_DISTANCE**2 && distSq > 0) { const dist = Math.sqrt(distSq); const repelForce = (TEAMMATE_REPULSION_DISTANCE - dist) / TEAMMATE_REPULSION_DISTANCE; repulsionDx += (player.x - teammate.x) / dist * repelForce * TEAMMATE_REPULSION_FORCE; repulsionDy += (player.y - teammate.y) / dist * repelForce * TEAMMATE_REPULSION_FORCE; } }); if (state === 'runningInitial' && player.ai.targetBunker) { const targetBunker = player.ai.targetBunker; const targetPointX = targetBunker.x + targetBunker.width / 2 + (player.team === selectedUserTeam ? PLAYER_RADIUS * 1.5 : -PLAYER_RADIUS * 1.5); const targetPointY = targetBunker.y + targetBunker.height / 2 + (Math.random() - 0.5) * targetBunker.height * 0.4; const distToTarget = Math.hypot(targetPointX - player.x, targetPointY - player.y); if (distToTarget < PLAYER_RADIUS * 1.5) { player.ai.state = 'patrolling'; player.ai.moving = false; player.ai.lastMoveTime = now; } else { const angle = Math.atan2(targetPointY - player.y, targetPointX - player.x); targetDx = Math.cos(angle) * player.speed * 1.2; targetDy = Math.sin(angle) * player.speed * 1.2; player.ai.moving = true; } } else if (state === 'patrolling') { if (now - player.ai.lastMoveTime > AI_MOVE_INTERVAL) { player.ai.lastMoveTime = now + Math.random() * 500; const centerDistX = Math.abs(player.x - canvas.width / 2); if (centerDistX > canvas.width * 0.25 && Math.random() < 0.6) { player.ai.targetX = canvas.width / 2 + (Math.random() - 0.5) * 100; player.ai.targetY = player.y + (Math.random() - 0.5) * 50; } else { player.ai.targetX = player.x + (Math.random() - 0.5) * AI_MOVE_TARGET_RANGE * 2; player.ai.targetY = player.y + (Math.random() - 0.5) * AI_MOVE_TARGET_RANGE * 2; } player.ai.targetX = Math.max(PLAYER_RADIUS * 2, Math.min(canvas.width - PLAYER_RADIUS * 2, player.ai.targetX)); player.ai.targetY = Math.max(PLAYER_RADIUS * 2, Math.min(canvas.height - PLAYER_RADIUS * 2, player.ai.targetY)); player.ai.moving = true; } if (player.ai.moving) { const distToTarget = Math.hypot(player.ai.targetX - player.x, player.ai.targetY - player.y); if (distToTarget > player.radius * 1.5) { const angle = Math.atan2(player.ai.targetY - player.y, player.ai.targetX - player.x); targetDx = Math.cos(angle) * player.speed; targetDy = Math.sin(angle) * player.speed; } else { player.ai.moving = false; } } } if (state !== 'spawning' && state !== 'runningInitial' && now - player.ai.lastShootTime > AI_SHOOT_INTERVAL) { player.ai.lastShootTime = now + Math.random() * 50; const opponents = (player.team === selectedUserTeam) ? team2Players : team1Players; let bestTarget = null; let minDistance = AI_VIEW_RANGE; opponents.forEach(opponent => { if (!opponent.isEliminated) { const dist = Math.hypot(player.x - opponent.x, player.y - opponent.y); if (dist < minDistance && hasLineOfSight(player.x, player.y, opponent.x, opponent.y)) { minDistance = dist; bestTarget = opponent; } } }); if (bestTarget) shootPaintball(player, bestTarget.x, bestTarget.y); } targetDx += repulsionDx; targetDy += repulsionDy; } if (Math.abs(targetDx) > 0.1 || Math.abs(targetDy) > 0.1) { player.facingAngle = Math.atan2(targetDy, targetDx); } let finalDx = 0, finalDy = 0; if (targetDx !== 0 || targetDy !== 0) { const magnitude = Math.hypot(targetDx, targetDy); const currentSpeed = (player.ai.state === 'runningInitial' && !player.isUser ? player.speed * 1.2 : player.speed); const effectiveSpeed = Math.min(currentSpeed, magnitude > 0 ? magnitude : currentSpeed); if (magnitude > 1e-6) { finalDx = (targetDx / magnitude) * effectiveSpeed; finalDy = (targetDy / magnitude) * effectiveSpeed; } } let nextX = player.x + finalDx; let nextY = player.y + finalDy; if (nextX - player.radius < 0) nextX = player.radius; if (nextX + player.radius > canvas.width) nextX = canvas.width - player.radius; if (nextY - player.radius < 0) nextY = player.radius; if (nextY + player.radius > canvas.height) nextY = canvas.height - player.radius; let collidedBunker = getCollidingBunker(nextX, nextY, player.radius); if (collidedBunker) { const closestX = Math.max(collidedBunker.x, Math.min(nextX, collidedBunker.x + collidedBunker.width)); const closestY = Math.max(collidedBunker.y, Math.min(nextY, collidedBunker.y + collidedBunker.height)); const collisionDx = nextX - closestX; const collisionDy = nextY - closestY; const collisionDist = Math.hypot(collisionDx, collisionDy); const normCollisionDx = (collisionDist > 0) ? collisionDx / collisionDist : 0; const normCollisionDy = (collisionDist > 0) ? collisionDy / collisionDist : 0; const overlap = player.radius - collisionDist; const pushBackAmount = (overlap > 0 ? overlap : 0) + 1.5; nextX = player.x + normCollisionDx * pushBackAmount; nextY = player.y + normCollisionDy * pushBackAmount; if (finalDx !== 0 || finalDy !== 0) { const moveMagnitude = Math.hypot(finalDx, finalDy); if (moveMagnitude > 1e-6) { const normMoveDx = finalDx / moveMagnitude; const normMoveDy = finalDy / moveMagnitude; const nudgeX = -normMoveDy * COLLISION_NUDGE_FACTOR * player.speed; const nudgeY = normMoveDx * COLLISION_NUDGE_FACTOR * player.speed; if (!getCollidingBunker(nextX + nudgeX, nextY + nudgeY, player.radius)) { nextX += nudgeX; nextY += nudgeY; } else if (!getCollidingBunker(nextX - nudgeX, nextY - nudgeY, player.radius)) { nextX -= nudgeX; nextY -= nudgeY; } } } if (!player.isUser) { player.ai.moving = false; if(player.ai.state === 'runningInitial') { player.ai.state = 'patrolling'; player.ai.lastMoveTime = now; } } } const allPlayers = [...team1Players, ...team2Players]; allPlayers.forEach(other => { if (player === other || other.isEliminated) return; const dist = Math.hypot(nextX - other.x, nextY - other.y); if (dist < player.radius + other.radius) { nextX = player.x; nextY = player.y; if (!player.isUser) player.ai.moving = false; } }); player.x = nextX; player.y = nextY; }
        function updatePaintballs() { /* ... same ... */ for (let i = paintballs.length - 1; i >= 0; i--) { const p = paintballs[i]; p.x += p.dx; p.y += p.dy; let removed = false; if (p.x + p.radius < 0 || p.x - p.radius > canvas.width || p.y + p.radius < 0 || p.y - p.radius > canvas.height) { paintballs.splice(i, 1); removed = true; continue; } if (isCollidingWithBunker(p.x, p.y, p.radius)) { createSplat(p.x, p.y, '#a0aec0'); paintballs.splice(i, 1); removed = true; if (audioHitBunker) { audioHitBunker.currentTime = 0; audioHitBunker.play().catch(e => console.error("Error playing bunker hit sound:", e)); } continue; } const targetTeamArray = (p.team === selectedUserTeam) ? team2Players : team1Players; for (let j = targetTeamArray.length - 1; j >= 0; j--) { const player = targetTeamArray[j]; if (!player.isEliminated) { const dist = Math.hypot(p.x - player.x, p.y - player.y); if (dist < p.radius + player.radius) { createSplat(p.x, p.y, p.color); player.isEliminated = true; paintballs.splice(i, 1); removed = true; if (audioHitPlayer) { audioHitPlayer.currentTime = 0; audioHitPlayer.play().catch(e => console.error("Error playing player hit sound:", e)); } if (player.team === selectedUserTeam) team1Score--; else team2Score--; updateScoreDisplay(); checkWinCondition(); break; } } } } }
        function updateSplats() { /* ... same ... */ const now = Date.now(); for (let i = splats.length - 1; i >= 0; i--) { const splat = splats[i]; if (now - splat.creationTime > splat.duration) { splats.splice(i, 1); } } }

        // --- Timer ---
        function startTimer() { /* ... same ... */ if (timerIntervalId) clearInterval(timerIntervalId); timeRemaining = selectedRoundTime; updateTimerDisplay(); timerIntervalId = setInterval(() => { if (!gameActive) { clearInterval(timerIntervalId); return; } timeRemaining--; updateTimerDisplay(); if (timeRemaining <= 0) { clearInterval(timerIntervalId); timerIntervalId = null; endGameByTime(); } }, 1000); }
        function updateTimerDisplay() { /* ... same ... */ timerDisplayElement.textContent = `Time: ${timeRemaining}`; }

        // --- Score and Win Condition ---
        function updateScoreDisplay() { /* ... same ... */ scoreTeam1Element.textContent = `${selectedUserTeam.name}: ${team1Score}`; scoreTeam1Element.style.color = selectedUserTeam.color; scoreTeam2Element.textContent = `${selectedOpponentTeam.name}: ${team2Score}`; scoreTeam2Element.style.color = selectedOpponentTeam.color; overallScoreDisplayElement.textContent = `Round: ${currentRoundNumber} / ${selectedRoundsPerMatch} | Wins: ${selectedUserTeam.name} ${team1GamesWon} - ${selectedOpponentTeam.name} ${team2GamesWon}`; }
        function checkWinCondition() { /* ... same ... */ if (!gameActive) return; if (team2Score <= 0) { team1GamesWon++; endGame(`${selectedUserTeam.name} Wins Round ${currentRoundNumber}!`); } else if (team1Score <= 0) { team2GamesWon++; endGame(`${selectedOpponentTeam.name} Wins Round ${currentRoundNumber}!`); } }
        function endGameByTime() { /* ... same ... */ if (!gameActive) return; let message = `Time's Up! Round ${currentRoundNumber} Over! `; if (team1Score > team2Score) { message += `${selectedUserTeam.name} Wins!`; team1GamesWon++; } else if (team2Score > team1Score) { message += `${selectedOpponentTeam.name} Wins!`; team2GamesWon++; } else { message += "It's a Draw!"; } endGame(message); }
        function endGame(roundEndMessage) { /* ... same ... */ if (!gameActive) return; gameActive = false; gameStateElement.textContent = "Round Over"; if (timerIntervalId) { clearInterval(timerIntervalId); timerIntervalId = null; } if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } updateScoreDisplay(); let userTeamWonRound = roundEndMessage.includes(selectedUserTeam.name + " Wins"); let opponentTeamWonRound = roundEndMessage.includes(selectedOpponentTeam.name + " Wins"); if (userTeamWonRound && audioWin) { audioWin.play().catch(e => console.error("Error playing win sound:", e)); } else if (opponentTeamWonRound && audioLose) { audioLose.play().catch(e => console.error("Error playing lose sound:", e)); } else if (audioLose) { audioLose.play().catch(e => console.error("Error playing lose/draw sound:", e)); } if (currentRoundNumber >= selectedRoundsPerMatch) { let matchWinnerMessage = "\n\n** MATCH OVER! **\n"; if (team1GamesWon > team2GamesWon) { matchWinnerMessage += `${selectedUserTeam.name} wins the match ${team1GamesWon} - ${team2GamesWon}!`; } else if (team2GamesWon > team1GamesWon) { matchWinnerMessage += `${selectedOpponentTeam.name} wins the match ${team2GamesWon} - ${team1GamesWon}!`; } else { matchWinnerMessage += `Match ends in a draw ${team1GamesWon} - ${team2GamesWon}!`; } showMessage(roundEndMessage + matchWinnerMessage + "\nClick Menu to play again.", 0); gameStateElement.textContent = "Match Over"; } else { showMessage(roundEndMessage + `\nStarting Round ${currentRoundNumber + 1}...`, NEXT_ROUND_DELAY - 500); setTimeout(() => { currentRoundNumber++; init(); }, NEXT_ROUND_DELAY); } }

        // --- Game Loop ---
        function gameLoop() { /* ... same ... */ animationFrameId = requestAnimationFrame(gameLoop); if (!gameActive) return; ctx.clearRect(0, 0, canvas.width, canvas.height); team1Players.forEach(updatePlayer); team2Players.forEach(updatePlayer); updatePaintballs(); updateSplats(); drawBunkers(); drawSplats(); team1Players.forEach(drawPlayer); team2Players.forEach(drawPlayer); drawPaintballs(); }

        // --- Initialization (Uses selected options) ---
        function init() { /* ... same ... */ console.log(`Initializing Round ${currentRoundNumber} / ${selectedRoundsPerMatch}`); gameActive = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } if (timerIntervalId) { clearInterval(timerIntervalId); timerIntervalId = null; } messageBox.style.display = 'none'; resizeCanvas(); switch (selectedMapLayout) { case 'nxl_2023': setupBunkersNXL2023(); break; case 'nxl_2020': setupBunkersNXL2020(); break; default: console.error("Unknown map layout selected:", selectedMapLayout); setupBunkersNXL2023(); } team1Score = selectedPlayerCount; team2Score = selectedPlayerCount; updateScoreDisplay(); gameStateElement.textContent = "Game State: Running"; paintballs.length = 0; splats.length = 0; team1Players.length = 0; team2Players.length = 0; const w = canvas.width; const h = canvas.height; const startXPadding = w * 0.05; const playerSpacingY = Math.min(h * 0.18, h / (selectedPlayerCount + 1)); const startYOffset = h * 0.5 - (playerSpacingY * (selectedPlayerCount -1) / 2); let team1StartBunkers = []; let team2StartBunkers = []; if (selectedMapLayout === 'nxl_2023') { team1StartBunkers = ['backCornerSnake_L', 'snakeSide_L', 'midCakeS_L', 'temple_L', 'dorito1_L', 'backCorner_L', 'snake1_L', 'midCanS_L', 'doritoSideCan_L', 'midCanD_L']; team2StartBunkers = ['backCornerSnake_R', 'snakeSide_R', 'midCakeS_R', 'temple_R', 'dorito1_R', 'backCorner_R', 'snake1_R', 'midCanS_R', 'doritoSideCan_R', 'midCanD_R']; } else if (selectedMapLayout === 'nxl_2020') { team1StartBunkers = ['backCornerTCK_L', 'snakeMiniCake_L', 'midBrick1_L', 'doritoMiniCake_L', 'dorito1_L', 'snake1_L', 'midBrick2_L', 'centerPin1_L', 'dorito2_L', 'snake2_L']; team2StartBunkers = ['backCornerTCK_R', 'snakeMiniCake_R', 'midBrick1_R', 'doritoMiniCake_R', 'dorito1_R', 'snake1_R', 'midBrick2_R', 'centerPin1_R', 'dorito2_R', 'snake2_R']; } for (let i = 0; i < selectedPlayerCount; i++) { const yPos = startYOffset + i * playerSpacingY; const isThisUser = (selectedPlayerCount === 1 || i === Math.floor(selectedPlayerCount / 2)); const team1P = createPlayer(selectedUserTeam, isThisUser); team1P.x = startXPadding; team1P.y = yPos; let attempts = 0; while (isCollidingWithBunker(team1P.x, team1P.y, team1P.radius) && attempts < 10) { team1P.x += PLAYER_RADIUS; attempts++; } if (!team1P.isUser) { if (team1StartBunkers.length > 0) { const bunkerName = team1StartBunkers[i % team1StartBunkers.length]; team1P.ai.targetBunker = bunkerLookup[bunkerName] || findNearestBunker(team1P.x, team1P.y); team1P.ai.state = team1P.ai.targetBunker ? 'runningInitial' : 'patrolling'; } else { team1P.ai.state = 'patrolling'; } } else { team1P.ai.state = 'userControlled'; userPlayer = team1P; } team1Players.push(team1P); const team2P = createPlayer(selectedOpponentTeam, false); team2P.x = w - startXPadding; team2P.y = yPos; attempts = 0; while (isCollidingWithBunker(team2P.x, team2P.y, team2P.radius) && attempts < 10) { team2P.x -= PLAYER_RADIUS; attempts++; } if (team2StartBunkers.length > 0) { const bunkerName = team2StartBunkers[i % team2StartBunkers.length]; team2P.ai.targetBunker = bunkerLookup[bunkerName] || findNearestBunker(team2P.x, team2P.y); team2P.ai.state = team2P.ai.targetBunker ? 'runningInitial' : 'patrolling'; } else { team2P.ai.state = 'patrolling'; } team2Players.push(team2P); } gameActive = true; if (currentRoundNumber === 1) { showMessage("Game Start!", 1500); } else { showMessage(`Round ${currentRoundNumber}!`, 1500); } if (audioStart) { audioStart.play().catch(e => console.error("Error playing start sound:", e)); } startTimer(); if (!animationFrameId) { gameLoop(); } }

        // --- Utility to show temporary messages ---
        function showMessage(text, duration = 2000) { /* ... same ... */ messageBox.textContent = text; messageBox.style.whiteSpace = 'pre-line'; messageBox.style.display = 'block'; if (messageBox.timeoutId) clearTimeout(messageBox.timeoutId); if (duration > 0) { messageBox.timeoutId = setTimeout(() => { if (messageBox.textContent === text) messageBox.style.display = 'none'; }, duration); } else { messageBox.timeoutId = null; } }

        // --- Canvas Resizing ---
        function resizeCanvas() { /* ... same ... */ const container = document.querySelector('.game-container'); const availableWidth = container.clientWidth - 32; const availableHeight = window.innerHeight - 150; const aspectRatio = 16 / 9; let canvasWidth = availableWidth; let canvasHeight = canvasWidth / aspectRatio; if (canvasHeight > availableHeight) { canvasHeight = availableHeight; canvasWidth = canvasHeight * aspectRatio; } const maxWidth = 1200; if (canvasWidth > maxWidth) { canvasWidth = maxWidth; canvasHeight = canvasWidth / aspectRatio; } const newWidth = Math.max(320, Math.floor(canvasWidth)); const newHeight = Math.max(180, Math.floor(canvasHeight)); if (canvas.width !== newWidth || canvas.height !== newHeight) { canvas.width = newWidth; canvas.height = newHeight; console.log(`Canvas resized to ${newWidth}x${newHeight}. Bunkers will be set on next init.`); } }
        window.addEventListener('resize', resizeCanvas);

        // --- Stop Game and Return to Menu ---
        function returnToMenu() { /* ... same ... */ console.log("Returning to menu..."); gameActive = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } if (timerIntervalId) { clearInterval(timerIntervalId); timerIntervalId = null; } gameContainer.classList.remove('active'); startMenu.style.display = 'flex'; team1GamesWon = 0; team2GamesWon = 0; currentRoundNumber = 1; updateScoreDisplay(); team1Players.length = 0; team2Players.length = 0; paintballs.length = 0; splats.length = 0; bunkers.length = 0; bunkerLookup = {}; gameStateElement.textContent = "Game State: Ready"; timerDisplayElement.textContent = "Time: 0"; messageBox.style.display = 'none'; }

        // --- Reset Button ---
        resetButton.addEventListener('click', init);

        // --- Menu Button ---
        menuButton.addEventListener('click', returnToMenu);

        // --- Start Menu Logic ---
        startButton.addEventListener('click', () => {
            // Read and validate options
            const count = parseInt(playerCountInput.value, 10); /* ... */ if (isNaN(count) || count < parseInt(playerCountInput.min) || count > parseInt(playerCountInput.max)) { alert(`Please enter a player count between ${playerCountInput.min} and ${playerCountInput.max}.`); return; } selectedPlayerCount = count;
            const time = parseInt(timeLimitInput.value, 10); /* ... */ if (isNaN(time) || time < parseInt(timeLimitInput.min) || time > parseInt(timeLimitInput.max)) { alert(`Please enter a time limit between ${timeLimitInput.min} and ${timeLimitInput.max} seconds.`); return; } selectedRoundTime = time;
            const rounds = parseInt(roundsInput.value, 10); /* ... */ if (isNaN(rounds) || rounds < parseInt(roundsInput.min) || rounds > parseInt(roundsInput.max)) { alert(`Please enter rounds per match between ${roundsInput.min} and ${roundsInput.max}.`); return; } selectedRoundsPerMatch = rounds;
            selectedMapLayout = mapLayoutInput.value;
            const userTeamId = userTeamSelect.value; /* ... */ const opponentTeamId = opponentTeamSelect.value; /* ... */ if (userTeamId === opponentTeamId) { alert("Please select different teams for user and opponent."); return; } selectedUserTeam = getTeamById(userTeamId); selectedOpponentTeam = getTeamById(opponentTeamId);

            // Reset match state
            team1GamesWon = 0; team2GamesWon = 0;
            currentRoundNumber = 1;

            // Hide menu, show game, start
            startMenu.style.display = 'none';
            gameContainer.classList.add('active');
            init();
        });

        // --- Populate Team Select Dropdowns ---
        function populateTeamSelects() { /* ... same ... */ teams.forEach((team, index) => { const optionUser = document.createElement('option'); optionUser.value = team.id; optionUser.textContent = team.name; userTeamSelect.appendChild(optionUser); const optionOpponent = document.createElement('option'); optionOpponent.value = team.id; optionOpponent.textContent = team.name; opponentTeamSelect.appendChild(optionOpponent); if (index === 0) userTeamSelect.value = team.id; if (index === 1) opponentTeamSelect.value = team.id; }); }


        // --- Initial Setup ---
        window.onload = function() {
            populateTeamSelects();
            updateScoreDisplay();
            resizeCanvas();
            console.log("Game ready. Waiting for start menu.");
        };

    </script>

</body>
</html>
